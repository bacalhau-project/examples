// Copyright (c) 2024 Expanso oss@expanso.io
// This software is licensed under the Apache2/MIT License.
// This was generated by Claude Sonnet 3.5, with the assistance of my human mentor

// bacalhau_client.go provides a client for interacting with the Bacalhau API server
// It's like a Swiss Army knife for distributed computing, but without the tiny scissors!

package bacalhau_client

import (
	"cmp"
	"context"
	"fmt"
	bacalhau_models "github.com/bacalhau-project/bacalhau/pkg/models"
	"github.com/bacalhau-project/bacalhau/pkg/publicapi/apimodels"
	api "github.com/bacalhau-project/bacalhau/pkg/publicapi/client/v2"
	"github.com/samber/lo"
	"net/http"
	"slices"
	"strings"
	//"github.com/bacalhau-project/projectweezer/internal/filter"
	//"github.com/bacalhau-project/projectweezer/internal/marketplace"
	//"github.com/bacalhau-project/projectweezer/internal/utils"

	bacalhau "github.com/bacalhau-project/bacalhau/pkg/publicapi/client/v2"
)

const (
	DefaultJobListCount  = 10000
	DefaultNodeListCount = 10000
	ClientVersion        = "1.0.0" // Add this line to define the client version
)

// BacalhauClient wraps the Bacalhau API client
type BacalhauClient struct {
	api api.API
}

func NewBacalhauClientFromAPI(api bacalhau.API) *BacalhauClient {
	return &BacalhauClient{api: api}
}

// NewBacalhauClient creates a new BacalhauClient
func NewBacalhauClient(endpoint string) (BacalhauClienter, error) {
	httpClient := &http.Client{
		Transport: &http.Transport{},
	}

	// Create a custom RoundTripper to add the version header
	customTransport := roundTripperFunc(func(req *http.Request) (*http.Response, error) {
		req.Header.Set("X-Frontend-Version", ClientVersion)
		return httpClient.Transport.RoundTrip(req)
	})

	bapi := api.New(endpoint,
		api.WithHTTPClient(&http.Client{Transport: customTransport}))
	client := NewBacalhauClientFromAPI(bapi)
	return client, nil
}

// roundTripperFunc allows us to use a function as an http.RoundTripper
type roundTripperFunc func(*http.Request) (*http.Response, error)

func (f roundTripperFunc) RoundTrip(req *http.Request) (*http.Response, error) {
	return f(req)
}

func (bc *BacalhauClient) API() bacalhau.API {
	return bc.api
}

func (bc *BacalhauClient) Alive(ctx context.Context) (bool, error) {
	resp, err := bc.api.Agent().Alive(ctx)
	if err != nil {
		return false, fmt.Errorf("failed to check if Bacalhau is alive: %w", err)
	}
	return resp.Status == "ok", nil
}

func (bc *BacalhauClient) Version(ctx context.Context) (*bacalhau_models.BuildVersionInfo, error) {
	resp, err := bc.api.Agent().Version(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get Bacalhau version: %w", err)
	}

	serverVersion := &bacalhau_models.BuildVersionInfo{
		Major:      resp.Major,
		Minor:      resp.Minor,
		GitVersion: resp.GitVersion,
		GitCommit:  resp.GitCommit,
		BuildDate:  resp.BuildDate,
		GOOS:       resp.GOOS,
		GOARCH:     resp.GOARCH,
	}

	return serverVersion, nil
}

// SubmitJob submits a new job to the Bacalhau network
// Returns the job ID
func (bc *BacalhauClient) SubmitJob(ctx context.Context, job *bacalhau_models.Job) (string, error) {
	resp, err := bc.api.Jobs().Put(ctx, &apimodels.PutJobRequest{
		Job: job,
	})
	if err != nil {
		return "", fmt.Errorf("failed to submit job: %w", err)
	}
	return resp.JobID, nil
}

// GetJobState retrieves the state of a job
func (bc *BacalhauClient) GetJobStatus(ctx context.Context, jobID string) (*bacalhau_models.State[bacalhau_models.JobStateType], error) {
	resp, err := bc.api.Jobs().Get(ctx, &apimodels.GetJobRequest{
		JobID: jobID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get job status: %w", err)
	}
	return &resp.Job.State, nil
}

// ListJobs retrieves a list of jobs
func (bc *BacalhauClient) ListJobs(ctx context.Context, filter string) ([]*bacalhau_models.Job, error) {
	return bc.ListJobsWithCount(ctx, DefaultJobListCount, filter)
}

func (bc *BacalhauClient) ListJobsWithCount(ctx context.Context, count int, filter string) ([]*bacalhau_models.Job, error) {
	listJobsRequest := &apimodels.ListJobsRequest{}
	listJobsRequest.Limit = uint32(count)

	resp, err := bc.api.Jobs().List(ctx, listJobsRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to list jobs: %w", err)
	}

	jobs := []*bacalhau_models.Job{}
	for _, job := range resp.Items {
		//if job != nil && applyJobFilter(job, filter) {
		jobs = append(jobs, job)
		//}
	}

	return jobs, nil
}

// ListQueuedJobs retrieves a list of jobs that are in the queued state
func (bc *BacalhauClient) ListQueuedJobs(ctx context.Context) ([]*bacalhau_models.Job, error) {
	jobState := bacalhau_models.JobStateTypeQueued
	jobs, err := bc.ListJobs(ctx, fmt.Sprintf("jobstate=%s", jobState))
	if err != nil {
		return nil, err
	}
	return jobs, nil
}

type JobFilter struct {
	Key   string
	Value string
}

// CancelJob cancels a running job
func (bc *BacalhauClient) CancelJob(ctx context.Context, jobID string) error {
	_, err := bc.api.Jobs().Stop(ctx, &apimodels.StopJobRequest{
		JobID: jobID,
	})
	if err != nil {
		if strings.Contains(err.Error(), "is in terminal state") {
			return nil
		}
		return fmt.Errorf("failed to cancel job: %w", err)
	}
	return nil
}

func (bc *BacalhauClient) GetJob(ctx context.Context, jobID string) (*bacalhau_models.Job, error) {
	resp, err := bc.api.Jobs().Get(ctx, &apimodels.GetJobRequest{
		JobID: jobID,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to get job: %w", err)
	}
	return resp.Job, nil
}

func (bc *BacalhauClient) GetJobInfo(ctx context.Context, jobID string) ([]*bacalhau_models.JobHistory,
	[]*bacalhau_models.Execution,
	*bacalhau_models.State[bacalhau_models.JobStateType], error) {
	resp, err := bc.api.Jobs().Get(ctx, &apimodels.GetJobRequest{
		JobID:   jobID,
		Include: "executions,history",
	})
	if err != nil {
		return nil, nil, nil, fmt.Errorf("failed to get job: %w", err)
	}

	// sorted executions
	var executions []*bacalhau_models.Execution
	if resp.Executions != nil {
		executions = resp.Executions.Items
	}
	slices.SortFunc(executions, func(a, b *bacalhau_models.Execution) int {
		return cmp.Compare(b.CreateTime, a.CreateTime)
	})

	// filtered job history
	var history []*bacalhau_models.JobHistory
	if resp.History != nil {
		history = resp.History.Items
	}
	jobHistory := lo.Filter(history, func(entry *bacalhau_models.JobHistory, _ int) bool {
		return entry.Type == bacalhau_models.JobHistoryTypeJobLevel
	})

	return jobHistory, executions, &resp.Job.State, nil
}

// ListNodes retrieves a list of all nodes in the Bacalhau network
func (bc *BacalhauClient) ListNodes(ctx context.Context) ([]*bacalhau_models.NodeState, error) {
	resp, err := bc.api.Nodes().List(ctx, &apimodels.ListNodesRequest{})
	if err != nil {
		return nil, fmt.Errorf("failed to list nodes: %w", err)
	}
	nodeStates := make([]*bacalhau_models.NodeState, len(resp.Nodes))
	for _, nodeState := range resp.Nodes {
		if nodeState != nil {
			nodeStates = append(nodeStates, nodeState)
		}
	}
	return nodeStates, nil
}

// PurgeDisconnectedNodes removes disconnected nodes from the network
func (bc *BacalhauClient) PurgeDisconnectedNodes(ctx context.Context) error {
	nodes, err := bc.api.Nodes().List(ctx, &apimodels.ListNodesRequest{})
	if err != nil {
		return fmt.Errorf("failed to list nodes: %w", err)
	}

	for _, node := range nodes.Nodes {
		_, err := bc.api.Nodes().Put(ctx, &apimodels.PutNodeRequest{
			NodeID: node.Info.NodeID,
			Action: string(apimodels.NodeActionDelete),
		})

		if err != nil {
			return fmt.Errorf("failed to purge disconnected nodes: %w", err)
		}
	}
	return nil
}
